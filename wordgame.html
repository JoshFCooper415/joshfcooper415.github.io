<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Association Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

        :root {
            --primary-color: #4a4e69;
            --secondary-color: #9a8c98;
            --accent-color: #c9ada7;
            --background-color: #f2e9e4;
            --text-color: #22223b;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .container {
            max-width: 1000px;
            width: 95%;
            margin: 2rem auto;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 1.5rem;
            text-align: center;
        }

        h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 600;
            text-transform: lowercase;
        }

        #game-container {
            padding: 1.5rem;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        .game-info span {
            font-weight: 600;
            color: var(--primary-color);
            text-transform: lowercase;
        }

        #definition {
            font-style: italic;
            background-color: var(--background-color);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            text-align: center;
            font-size: 1.1rem;
            line-height: 1.6;
            text-transform: lowercase;
        }

        #graph-container {
            width: 100%;
            height: 400px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            fill: var(--secondary-color);
            stroke: var(--primary-color);
            stroke-width: 2px;
        }

        .node text {
            font-size: 12px;
            fill: var(--text-color);
            text-transform: lowercase;
        }

        .link {
            fill: none;
            stroke: var(--accent-color);
            stroke-width: 1.5px;
        }

        #attempts {
            text-align: center;
            font-size: 1.2rem;
            margin-top: 1rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        @media (max-width: 768px) {
            .container {
                width: 98%;
            }

            h1 {
                font-size: 2rem;
            }

            .game-info {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }

            #graph-container {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>word association graph game</h1>
        </header>
        <div id="game-container">
            <div class="game-info">
                <p>starting word: <span id="start-word"></span></p>
                <p>target word: <span id="target-word"></span></p>
                <p>current word: <span id="current-word"></span></p>
            </div>
            <p id="definition"></p>
            <div id="graph-container"></div>
            <p id="attempts"></p>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const apiUrl = 'https://api.dictionaryapi.dev/api/v2/entries/en/';
        let startWord, targetWord, currentWord, maxAttempts, attemptsLeft;
        const visitedWords = new Set();
        let graphData = { nodes: [], links: [] };
        let simulation;
        let svg, g;

        function cleanWord(word) {
            return word.replace(/[^a-zA-Z]/g, '').toLowerCase();
        }

        function cleanText(text) {
            return text.replace(/[^a-zA-Z\s]/g, '').toLowerCase();
        }

        async function fetchWordData(word) {
            const cleanedWord = cleanWord(word);
            try {
                const response = await fetch(apiUrl + cleanedWord);
                if (!response.ok) throw new Error('Word not found');
                const data = await response.json();
                return data[0];
            } catch (error) {
                console.error('Error fetching word data:', error);
                return null;
            }
        }

        function updateUI() {
            document.getElementById('start-word').textContent = startWord.toLowerCase();
            document.getElementById('target-word').textContent = targetWord.toLowerCase();
            document.getElementById('current-word').textContent = currentWord.toLowerCase();
            document.getElementById('attempts').textContent = `attempts left: ${attemptsLeft}`;
        }

        function getPriorityScore(partOfSpeech) {
            switch (partOfSpeech) {
                case 'noun': return 3;
                case 'verb': return 2;
                case 'adjective': return 1;
                default: return 0;
            }
        }

        function getTopWords(wordData, limit = 5) {
            const wordsWithPriority = [];
            wordData.meanings.forEach(meaning => {
                const partOfSpeech = meaning.partOfSpeech;
                meaning.definitions.forEach(def => {
                    const words = cleanText(def.definition).split(/\s+/);
                    words.forEach(word => {
                        if (word.length > 3 && !visitedWords.has(word)) {
                            wordsWithPriority.push({
                                word: word,
                                priority: getPriorityScore(partOfSpeech)
                            });
                        }
                    });
                });
            });

            // Remove duplicates and sort by priority
            const uniqueWords = Array.from(new Set(wordsWithPriority.map(w => w.word)))
                .map(word => {
                    return {
                        word: word,
                        priority: Math.max(...wordsWithPriority.filter(w => w.word === word).map(w => w.priority))
                    };
                })
                .sort((a, b) => b.priority - a.priority || Math.random() - 0.5);

            return uniqueWords.slice(0, limit).map(w => w.word);
        }

        function updateGraph(newWord, topWords) {
            const newNodes = topWords.filter(word => !graphData.nodes.some(node => node.id === word))
                                     .map(word => ({ id: word }));
            graphData.nodes.push(...newNodes);
            
            const newLinks = topWords.map(word => ({ source: newWord, target: word }));
            graphData.links.push(...newLinks);

            renderGraph();
        }

        function renderGraph() {
            const width = document.getElementById('graph-container').clientWidth;
            const height = 400;

            if (!svg) {
                svg = d3.select("#graph-container")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

                g = svg.append("g");

                svg.call(d3.zoom()
                    .extent([[0, 0], [width, height]])
                    .scaleExtent([0.1, 8])
                    .on("zoom", zoomed));

                function zoomed({transform}) {
                    g.attr("transform", transform);
                }
            }

            if (!simulation) {
                simulation = d3.forceSimulation(graphData.nodes)
                    .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(100))
                    .force("charge", d3.forceManyBody().strength(-200))
                    .force("center", d3.forceCenter(width / 2, height / 2));
            } else {
                simulation.nodes(graphData.nodes);
                simulation.force("link").links(graphData.links);
                simulation.alpha(1).restart();
            }

            const link = g.selectAll(".link")
                .data(graphData.links)
                .join("line")
                .attr("class", "link");

            const node = g.selectAll(".node")
                .data(graphData.nodes)
                .join("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            node.selectAll("circle")
                .data(d => [d])
                .join("circle")
                .attr("r", 20);

            node.selectAll("text")
                .data(d => [d])
                .join("text")
                .text(d => d.id)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'central');

            node.on("click", (event, d) => handleWordClick(d.id));

            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            });

            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
        }

        async function handleWordClick(word) {
            const cleanedWord = cleanWord(word);
            if (cleanedWord === targetWord.toLowerCase()) {
                alert(`congratulations! you've reached the target word '${targetWord}' in ${maxAttempts - attemptsLeft + 1} attempts.`);
                startGame();
                return;
            }

            if (visitedWords.has(cleanedWord)) {
                alert('you have already used this word. try another one.');
                return;
            }

            attemptsLeft--;
            currentWord = word;
            visitedWords.add(cleanedWord);
            updateUI();

            if (attemptsLeft === 0) {
                alert(`game over. you didn't reach '${targetWord}' within ${maxAttempts} attempts.`);
                startGame();
                return;
            }

            const wordData = await fetchWordData(cleanedWord);
            if (wordData) {
                const topWords = getTopWords(wordData);
                document.getElementById('definition').textContent = wordData.meanings[0].definitions[0].definition.toLowerCase();
                updateGraph(cleanedWord, topWords);
            } else {
                alert('failed to fetch word data. please try again.');
            }
        }

        async function startGame() {
            startWord = 'Hello';
            targetWord = 'World';
            currentWord = startWord;
            maxAttempts = 10;
            attemptsLeft = maxAttempts;
            visitedWords.clear();
            visitedWords.add(cleanWord(startWord));
            graphData = { nodes: [{ id: startWord.toLowerCase() }], links: [] };
            simulation = null;
            svg = null;
            g = null;

            updateUI();

            const wordData = await fetchWordData(startWord);
            if (wordData) {
                const topWords = getTopWords(wordData);
                document.getElementById('definition').textContent = wordData.meanings[0].definitions[0].definition.toLowerCase();
                updateGraph(startWord.toLowerCase(), topWords);
            } else {
                alert('failed to start the game. please refresh the page.');
            }
        }

        window.onload = startGame;
    </script>
</body>
</html>